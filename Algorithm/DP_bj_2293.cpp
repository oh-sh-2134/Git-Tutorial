#include<iostream>
#define MAX 10001

using namespace std;

int coin[100];
int dp[MAX];
int n, k;

int main(void) {
	cin >> n >> k;
	for (int i = 1; i <= n; i++) {
		cin >> coin[i];
	}
	dp[0] = 1;
	for (int i = 1; i <= n; i++) {
		for (int j = coin[i]; j <= k; j++) {
			if(j-coin[i] >= 0)
				dp[j] = dp[j] + dp[j - coin[i]];
		}
	}
	cout << dp[k];
}
//https://www.acmicpc.net/problem/2293
/*
3 10
1
2
5
*/
//처음에는 위의 예시 코드가 들어오면 dp[i] = dp[i-1] + dp[i-2] + dp[i+5] 의 점화식으로
//풀릴줄 알았는데 점화식으로 풀 경우 3원에서 (2 1) (1 2)와 같이 동전의 배치가 다른경우
//각각의 케이스로 들어가서 중복제거를 할 수 없었다 그래서 각 동전의 가치가 속할 수 있는 케이스를 찾아봄
//예제의 경우에 2원은 1원의 조합에 들어갈 수 없고 5원은 5원 미만의 조합에 들어갈 수 없다
//그래서 10원까지 1원으로 조합하는 경우, 1원 2원으로 조합한 경우, 1 2 5원으로 조합한 경우를 순차적으로 더해감
//	1	2	3	4	5	6	7	8	9	10
//	1	1	1	1	1	1	1	1	1	1		1원으로 조합할 수있는 경우의 수
//	0	1	0	1	0	1	0	1	0	1		2원으로 조합할 수 있는 경우의 수
//	1	2	2	3	3	4	4	5	5	6		1원과 2원으로 조합 할 수 있는 경우의 수
//	이런식으로 더해나가면
//	0	0	0	0	1	0	0	0	0	1		5원으로 조합할 수 있는 경우의 수
//	1	2	2	3	4	6	6	9	9	10		1,2,5원으로 조합할 수 있는 경우의 수
// dp문제는 규칙 찾는게 정말 힘들다.